04/23/2015

Some important parameters in sphere class(same for every sphere object)
         Refinement: The depth of recursion of subdivisions, a nonnegative number. The intuition behind the subdivisions is that the more subdivision a programs does,
         the sphere looks more smooth. Therefore, increasing refinement should enhance the quality of sphere rendering. The tradeoff is the cost
         of computation. Currently, refinement is set to 2 because it looks good enough on my phone. We could variate it in future.
         
         NUM_OF_FACES: the number of triangles on the sphere. Same as refinement, more NUM_OF_FACES, more smooth the sphere is.
         
         These two parameters are specified at the very beginning of Sphere class. Be sure to change them correctly and together, otherwise it wouldn't
         compile. 
         Actually there is an easy formula that I invented for calculating NUM_OF_FACES:
                  NUM_OF_FACES = 20 * (4 ^ refinement)
         I was just so lazy to implement this formula. +.+ It is still something that needs doing...
         

Corrected the geometric algorithm:
         1.We used to generate a sphere at targeted coordinates for each spheres, which drew weird shape spheres, maybe because of the formula for normalization
         The right way : we should first generate a sphere at the origin and then push that sphere to the targeted coordinates.
         2. Decrease all coordinates by a factor of 10. Since our OPENGL universe is in a box of volume 1, we can't render things outside the box. Maybe it is another reason for the previous weird shapes

05/01/2015
The formula for detecting a switching:

The formula now is
 if(v[0]> 0.95 && v[1] <0.5 && v[2] < 0.5)
     then switch.

Where v is the upVector of the world created in app.
There are three components in v, each component of v is a float between [0,1]
I think the norm for v should be 1. Hence, if one component, say v[0], is dominant, the other two, v[1] and v[2], could be pretty small.

 If the phone is held portrait, v[0] is the dominant component
 If the phone is held landscape, which is usually the case for Cardboard App, v[1] is the dominant component
 If the phone is put flat on table, v[2] is the dominant component

We used this feature to detect whether the user wants to switch molecules. Since they usually hold the phone in landscape mode/ flat mode when they use
CardBoard headset, one component, v[0], should be small for the most of the time. When this component is dominant, we can regard it as an action that user
does it on purpose--tilting their heads..

And we have a timer in onNewFrame() thread which refreshed v value once per hundred times.

Parameters that maybe reconfigured later:
Criteria for a switching: now is x>0.95, y <0.5, z <0.5
Looping time: 100 times
Normalizing factor for molecule: now *(1/15)
Distance from origin: now 0.0
Background Color: now Black
Initial Molecule: now 0

05/07/2015
Add the color-assigning feature to the app:
1.A file, colorpicker.txt, in /raw has the colors for each element. You can write comment in this file.
    The format for writing this file is
    [Element Symbol] [Red Component] [Green Component] [Blue Component]
    e.g.H 239 187 242 is giving H a pinkish color with RGB values in scale of 256
2.A method of TextParser.java, loadColor(BufferedReader bf), has been added
    This method takes an input of a file through a bufferedReader that is formatted as colorpicker.txt and
    uses its coloring to update ColorHashTable, a hashmap that stores color for each element
3. In surfaceCreated method, parser.loadColor() is called before parser.parse() to predefine coloring of elements
4. Found a bug in parser.parse().
    The parser can only parse lines before 98.


05/18/2015
1.Fix the bug in parser.parse()
    The parser now should be able to read through a table in raw data
2.Add a file, cpk_coloring to raw folder. This is a coloring conventionally used by chemists, so we adapt to this coloring.
3.Pre-normalize coordinates in given molecule data.
 After normalization, all coordinates(x,y,z) should be in range [-0.8,0.8].
 An atom set at 0.8 is the maximum(rightmost, uppermost, or farthest) atom in that dimension
 Inversely, an atom set at -0.8 is the minimum(leftmost, lowermost, or nearest) atom in that dimension.
 The rest of atoms are linearly interpolated between -0.8 and 0.8.
 Specific Normalization Formula:
        z_i = 1.6 * ( (x_i - min)/(max - min) - 0.5 )
 The reason why 0.8 is used instead of 1.0 is to provide a better vision of the whole molecule(no clipping on edges of models)
4.Modified the algorithm to modeling.
    (i).Instead of creating spheres along with parsing a text file, now the program first finished all parsing job and then creating spheres based on normalized
    coordinates. The normalization has to happen after all parsing because it requires to know all coordinates in a molecule.
        This change happens in TextParser.parse()
     (ii).Since the coordinates given in text-file is not necessarily between [-1.0,1.0], they need to be resized before modelling.
     Without normalization,the program used to adopt a dumb approach to resize: it defined a temporary "refactoring constant" UB, then divided all coordinates by
     UB. The value of VB is determined merely by experiments and is not guaranteed to be a precise value at all. Now that there is normalization, UB is not needed.
        However, there is still trace of UB remained in Sphere.setCoordinate() because of another resizing! We generated Spheres with different centers but the program
     didn't assign radius to them yet. Hence, UB, as a spare variable, is a convenient constant to represent a "uniform radius" that is applied to all atoms.
     I know it is a lazy & dangerous practice to reuse an existing variable for a different purpose, but for the sake of now, just leave it there.
     I'll implement radius feature immediately as the first task and get rid of UB completely.


Parameters that maybe reconfigured later:
Criteria for a switching: now is x>0.95, y <0.5, z <0.5
Looping time: 100 times
Size of frame of molecules: [-0.8,0.8]*[-0.8,0.8]*[-0.8,0.8]
Distance from origin: now 0.0
Background Color: now Black
Initial Molecule: now 2

TODO_LIST:
        1.Assign radius to each kind of atom, choose whatever number that suits. Although the radius should be related to an atom's atomic number, don't make a He atom as twice as big as an H atom
         because the size of screen is really limited. The ratio of the lightest atom to the heaviest atom shouldn't be over 1/4
