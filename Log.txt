04/23/2015

Some important parameters in sphere class(same for every sphere object)
         Refinement: The depth of recursion of subdivisions, a nonnegative number. The intuition behind the subdivisions is that the more subdivision a programs does,
         the sphere looks more smooth. Therefore, increasing refinement should enhance the quality of sphere rendering. The tradeoff is the cost
         of computation. Currently, refinement is set to 2 because it looks good enough on my phone. We could variate it in future.
         
         NUM_OF_FACES: the number of triangles on the sphere. Same as refinement, more NUM_OF_FACES, more smooth the sphere is.
         
         These two parameters are specified at the very beginning of Sphere class. Be sure to change them correctly and together, otherwise it wouldn't
         compile. 
         Actually there is an easy formula that I invented for calculating NUM_OF_FACES:
                  NUM_OF_FACES = 20 * (4 ^ refinement)
         I was just so lazy to implement this formula. +.+ It is still something that needs doing...
         

Corrected the geometric algorithm:
         1.We used to generate a sphere at targeted coordinates for each spheres, which drew weird shape spheres, maybe because of the formula for normalization
         The right way : we should first generate a sphere at the origin and then push that sphere to the targeted coordinates.
         2. Decrease all coordinates by a factor of 10. Since our OPENGL universe is in a box of volume 1, we can't render things outside the box. Maybe it is another reason for the previous weird shapes

05/01/2015
The formula for detecting a switching:

The formula now is
 if(v[0]> 0.95 && v[1] <0.5 && v[2] < 0.5)
     then switch.

Where v is the upVector of the world created in app.
There are three components in v, each component of v is a float between [0,1]
I think the norm for v should be 1. Hence, if one component, say v[0], is dominant, the other two, v[1] and v[2], could be pretty small.

 If the phone is held portrait, v[0] is the dominant component
 If the phone is held landscape, which is usually the case for Cardboard App, v[1] is the dominant component
 If the phone is put flat on table, v[2] is the dominant component

We used this feature to detect whether the user wants to switch molecules. Since they usually hold the phone in landscape mode/ flat mode when they use
CardBoard headset, one component, v[0], should be small for the most of the time. When this component is dominant, we can regard it as an action that user
does it on purpose--tilting their heads..

And we have a timer in onNewFrame() thread which refreshed v value once per hundred times.

Parameters that maybe reconfigured later:
Criteria for a switching: now is x>0.95, y <0.5, z <0.5
Looping time: 100 times
Normalizing factor for molecule: now *(1/15)
Distance from origin: now 0.0
Background Color: now Black
Initial Molecule: now 0

05/07/2015
Add the color-assigning feature to the app:
1.A file, colorpicker.txt, in /raw has the colors for each element. You can write comment in this file.
    The format for writing this file is
    [Element Symbol] [Red Component] [Green Component] [Blue Component]
    e.g.H 239 187 242 is giving H a pinkish color with RGB values in scale of 256
2.A method of TextParser.java, loadColor(BufferedReader bf), has been added
    This method takes an input of a file through a bufferedReader that is formatted as colorpicker.txt and
    uses its coloring to update ColorHashTable, a hashmap that stores color for each element
3. In surfaceCreated method, parser.loadColor() is called before parser.parse() to predefine coloring of elements
4. Found a bug in parser.parse().
    The parser can only parse lines before 98.

TODO_LIST:
        0.Define and calculate the normalization factor(upperbound for coordinates):
          Because our OPENGL coordinates only allow coordinate be in range (-1,1) for all x,y,z coordinates, some atoms with large value for coordinates such as
          62 H   H28        -0.19378    9.96085    7.70894, 
          are really hard to draw.
          So for each atom(sphere), we want to define a upperbound value UB such that all coordiantes are smaller than UB.
          Right now UB is set to a constant 10, but we want to make it a variable that is initiazed when a sphere is created.
          This initialization should be along with that for color, x, y, z and radius.
        1.Assign radius to each kind of atom, choose whatever number that suits. Although the radius should be related to an atom's atomic number, don't make a He atom as twice as big as an H atom
         because the size of screen is really limited. The ratio of the lightest atom to the heaviest atom shouldn't be over 1/4 
        2.fix the tilt of molecule(Don't worry now, long-term goal)

05/18/2015
1.Fix the bug in parser.parse()
    The parser now should be able to read through a table in raw data
2.Add a file, cpk_coloring to raw folder. This is a coloring conventionally used by chemists, so we adapt to this coloring.

