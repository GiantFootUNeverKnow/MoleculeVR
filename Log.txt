04/23/2015

Some important parameters in sphere class(same for every sphere object)
         Refinement: The depth of recursion of subdivisions, a nonnegative number. The intuition behind the subdivisions is that the more subdivision a programs does,
         the sphere looks more smooth. Therefore, increasing refinement should enhance the quality of sphere rendering. The tradeoff is the cost
         of computation. Currently, refinement is set to 2 because it looks good enough on my phone. We could variate it in future.
         
         NUM_OF_FACES: the number of triangles on the sphere. Same as refinement, more NUM_OF_FACES, more smooth the sphere is.
         
         These two parameters are specified at the very beginning of Sphere class. Be sure to change them correctly and together, otherwise it wouldn't
         compile. 
         Actually there is an easy formula that I invented for calculating NUM_OF_FACES:
                  NUM_OF_FACES = 20 * (4 ^ refinement)
         I was just so lazy to implement this formula. +.+ It is still something that needs doing...
         

Corrected the geometric algorithm:
         1.We used to generate a sphere at targeted coordinates for each spheres, which drew weird shape spheres, maybe because of the formula for normalization
         The right way : we should first generate a sphere at the origin and then push that sphere to the targeted coordinates.
         2. Decrease all coordinates by a factor of 10. Since our OPENGL universe is in a box of volume 1, we can't render things outside the box. Maybe it is another reason for the previous weird shapes

05/01/2015
The formula for detecting a switching:

The formula now is
 if(v[0]> 0.95 && v[1] <0.5 && v[2] < 0.5)
     then switch.

Where v is the upVector of the world created in app.
There are three components in v, each component of v is a float between [0,1]
I think the norm for v should be 1. Hence, if one component, say v[0], is dominant, the other two, v[1] and v[2], could be pretty small.

 If the phone is held portrait, v[0] is the dominant component
 If the phone is held landscape, which is usually the case for Cardboard App, v[1] is the dominant component
 If the phone is put flat on table, v[2] is the dominant component

We used this feature to detect whether the user wants to switch molecules. Since they usually hold the phone in landscape mode/ flat mode when they use
CardBoard headset, one component, v[0], should be small for the most of the time. When this component is dominant, we can regard it as an action that user
does it on purpose--tilting their heads..

And we have a timer in onNewFrame() thread which refreshed v value once per hundred times.

Parameters that maybe reconfigured later:
Criteria for a switching: now is x>0.95, y <0.5, z <0.5
Looping time: 100 times
Normalizing factor for molecule: now *(1/15)
Distance from origin: now 0.0
Background Color: now Black
Initial Molecule: now 0

05/07/2015
Add the color-assigning feature to the app:
1.A file, colorpicker.txt, in /raw has the colors for each element. You can write comment in this file.
    The format for writing this file is
    [Element Symbol] [Red Component] [Green Component] [Blue Component]
    e.g.H 239 187 242 is giving H a pinkish color with RGB values in scale of 256
2.A method of TextParser.java, loadColor(BufferedReader bf), has been added
    This method takes an input of a file through a bufferedReader that is formatted as colorpicker.txt and
    uses its coloring to update ColorHashTable, a hashmap that stores color for each element
3. In surfaceCreated method, parser.loadColor() is called before parser.parse() to predefine coloring of elements
4. Found a bug in parser.parse().
    The parser can only parse lines before 98.


05/18/2015
1.Fix the bug in parser.parse()
    The parser now should be able to read through a table in raw data
2.Add a file, cpk_coloring to raw folder. This is a coloring conventionally used by chemists, so we adapt to this coloring.
3.Pre-normalize coordinates in given molecule data.
 After normalization, all coordinates(x,y,z) should be in range [-0.8,0.8].
 An atom set at 0.8 is the maximum(rightmost, uppermost, or farthest) atom in that dimension
 Inversely, an atom set at -0.8 is the minimum(leftmost, lowermost, or nearest) atom in that dimension.
 The rest of atoms are linearly interpolated between -0.8 and 0.8.
 Specific Normalization Formula:
        z_i = 1.6 * ( (x_i - min)/(max - min) - 0.5 )
 The reason why 0.8 is used instead of 1.0 is to provide a better vision of the whole molecule(no clipping on edges of models)
4.Modified the algorithm to modeling.
    (i).Instead of creating spheres along with parsing a text file, now the program first finished all parsing job and then creating spheres based on normalized
    coordinates. The normalization has to happen after all parsing because it requires to know all coordinates in a molecule.
        This change happens in TextParser.parse()
     (ii).Since the coordinates given in text-file is not necessarily between [-1.0,1.0], they need to be resized before modelling.
     Without normalization,the program used to adopt a dumb approach to resize: it defined a temporary "refactoring constant" UB, then divided all coordinates by
     UB. The value of VB is determined merely by experiments and is not guaranteed to be a precise value at all. Now that there is normalization, UB is not needed.
        However, there is still trace of UB remained in Sphere.setCoordinate() because of another resizing! We generated Spheres with different centers but the program
     didn't assign radius to them yet. Hence, UB, as a spare variable, is a convenient constant to represent a "uniform radius" that is applied to all atoms.
     I know it is a lazy & dangerous practice to reuse an existing variable for a different purpose, but for the sake of now, just leave it there.
     I'll implement radius feature immediately as the first task and get rid of UB completely.


Parameters that maybe reconfigured later:
Criteria for a switching: now is x>0.95, y <0.5, z <0.5
Looping time: 100 times
Size of frame of molecules: [-0.8,0.8]*[-0.8,0.8]*[-0.8,0.8]
Distance from origin: now 0.0
Background Color: now Black
Initial Molecule: now 2

05/19/2015
0.Added a file atommass.txt which has atomic mass for all elements
1.Added a method TextParser.loadAtomMass() that could load atomic mass for each element from atommass.txt
2.Adjust radius of a sphere according to the atomic mass of that element by the following algorithm:
    After TextParser finishes parsing, it stores atomic masses of all atoms in the molecule to an array and normalizes their masses
        The formula used for normalization:
        z_i = ( (x_i - min)/(max - min) + 1 ), where max&&min are the maximum && minimum of the array
    Hence, the resulting masses are between 1.0f and 2.0f.
        An atom with normalized mass 2.0f is the heaviest atom of the molecule
        An atom with normalized mass 1.0f is the lightest atom of the molecule
        (This 2:1 ratio is adjustable)
    Then TextParser passes masses to Sphere constructor as one argument.
    Sphere class generates a sphere by using this formula to normalize its vertices
        vertices[i] = (vertices[i]  * radius )/RESIZING_FACTOR + xCoord
        ~~ + yCoord
        ~~ + zCoord
        RESIZING_FACTOR is also an adjustable constant
3. Filter out invalid arguments passed into Sphere's constructor. If there is any illegal argument, IllegalArgumentException would occur
4. Sophisticate TextParser.normalize()
    Temporarily option a is used for normalizing coordinates, normalizing a random array to range [-0.8f,0.8f]
                option b is used for normalizing atomic masses, normalizing a random array to range [1.0f,2.0f]
    Details are on the comments of codes
5. Generalize the codes for read in more molecules file. Now, the only change that is needed to incorporate more molecules is to change the constant
    NUM_OF_MOLECULES.
        Be sure to add molecules in the natural order. e.g. molecule4 following molecule3

Parameters that maybe reconfigured later:
Criteria for a switching: now is x>0.95, y <0.5, z <0.5
Looping time: 100 times
Size of frame of molecules: [-0.8,0.8]*[-0.8,0.8]*[-0.8,0.8]
Range of radii of atoms; [1.0,2.0]
RESIZING_FACTOR: 20
Distance from origin: now 0.0
Background Color: now Black
Initial Molecule: now 2

05/21/2015
1.Add oscillation feature to molecule
    -A new function called adjustVertices(int index) will be called each time a frame is drawn,
    which takes care of various adjustment to molecule that could be added in future
    -By now, this function moves each atom by a random translational vector that is within scale 0.01
    i.e. all components of the vector should be at most 0.01, at least -0.01. For each frame, different random vectors
    would be generated and used to different atoms. Basically, these atoms shake irregularly.
2. It seems to be bit hard for a large cell to move, the calculation is quite large. Maybe consider to use another Timer to control the oscillation or
oscillate once for every few frames

05/22/2015
1.Temporarily shut down/ commented out the feature of oscillation because this feature needs heavy workload on each frame
2.Added an attribute elem_name to Sphere class that would be passed in when initialization
    -There is no argument checking for this argument, leave it blank when it is still unnecessary
3.Managed to draw bondings on screen
    The whole process is described as follows:
    (i.)On the last step of method TextParser.parse() after all information of atoms are known and properly processed, the program calls a new method
        TextParser.createBonds()
    (ii.)All calculations about the decision if two atoms should be connected through a bond are done within createBonds()
        An atom is only connected to a group of atoms that are in the shortest distance from it.
        The program constructed a hashTable that records such group of atoms for each atom.
        This group of atoms is found by a linearly search for minimum distance through all atoms in that molecule.
        (*)Concern1: Right now, as a result of this algorithm, sizes of the group "Nearest Neighbors" described above is always 1. A bit suspicious!
            I guess for some atom in the sample, such as Nitrogen, their number of nearest neighbors should be three hydrogen atoms.
        (*)Concern2: This algorithm could be accelerated by construction of a K-d Tree. (Takes approximately 3 hours to do such a boost)
        (*)Concern3: Finding such "Nearest Neighbors" may not be very meaningful. For example, the nearest neighbor of some Bromine in the sample would be
            a hydrogen, but in reality, they are not supposed to be connected. The Bromine belongs to the cage that is consisted of Pb and Br.
    (iii.)Interface for communications between MainActivity and TextParser is established by three functions
        TextParser.outputBonds(),TextParser.outputBondingColors(), TextParser.outputNumOfBonds()
        outputBonds() reformats the hashTable "Nearest Neighbors" built in step(ii) to a simple array readable by functions in MainActivity
        outputBindingColors() loads in coloring for a bond connecting two atoms by interpolation of colors of those two atoms
        outputNumOfBonds() simply returns a private variable of TextParser that records number of bonding for the molecule.
            This value would be reset each time createBonds() is called
    (iv.)In MainActivity.onSurfaceCreated(), the program constructs an OPENGL program for rendering bonding in the same way it renders atoms of the molecule
        This program would be fed in data from the output of the interfaces described in (iii.)
    (v.) All the framework codes for rendering atoms and rendering bondings are similar except that we use GL.LINES for bondings instead of GL.TRIANGLES
        drawBondings() method would be called after drawMolecule()
            (*)Concern4: Wouldn't doing just GL.LINES be so simple representation of a bond? Considering adjust thickness of these OPENGL lines
            (*)Concern5: Will oscillation feature implemented before be smoothly applied to a molecule with bondings? I am afraid that the shaking makes lines
                discontinue
    (vi.) All variables used to build a molecule have their counterparts for building bondings

TODOLIST: solve concerns described above.

Parameters that maybe reconfigured later:
Criteria for a switching: now is x>0.95, y <0.5, z <0.5
Looping time: 100 times
Size of frame of molecules: [-0.8,0.8]*[-0.8,0.8]*[-0.8,0.8]
Range of radii of atoms; [1.0,2.0]
RESIZING_FACTOR: 20
Distance from origin: now 0.0
Background Color: now Black
Initial Molecule: now 5
Scale of oscillation: [-0.01,0.01]